/*
Copyright 2021 The Doctl Authors All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// TODO perhaps this doesn't belong in commands
package commands

import (
	"errors"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"

	"github.com/digitalocean/godo"
)

// Highly experimental hack to use 'nim' in conjunction with doctl.

// Top level function to deploy serverless actions in the form of Nimbella projects
func deployServerless(projects []*godo.AppServerlessSpec) (string, error) {
	var nimProjects = []string{}
	for _, project := range projects {
		nimProject, err := convertToNimProject(project)
		if err != nil {
			return "", err
		}
		nimProjects = append(nimProjects, nimProject)
	}
	args := append([]string{"project", "deploy", "--exclude", "web"}, nimProjects...)
	return runNim(args...)
}

// Function to convert a godo.AppServerlessSpec to a concrete project location that 'nim' can deploy
// (either GitHub resident or local)
func convertToNimProject(spec *godo.AppServerlessSpec) (string, error) {
	if spec.Local == nil {
		if spec.GitHub == nil {
			return "", errors.New("one of `Local` or `GitHub` must appear in a `serverless` spec")
		} else {
			return githubProject(spec.GitHub, spec.SourceDir)
		}
	} else if spec.GitHub != nil {
		return "", errors.New("you cannot specify both `Local` and `GitHub` in a `serverless` spec")
	} else {
		return localProject(spec.Local, spec.SourceDir)
	}
}

// Function to convert godo.GitHubSourceSpec + source directory path to an appropriate project argument
// for 'nim project deploy'
func githubProject(spec *godo.GitHubSourceSpec, sourceDir string) (string, error) {
	if spec.DeployOnPush {
		return "", errors.New("the `deploy on push` feature is not currently supported for serverless")
	}
	if spec.Repo == "" {
		return "", errors.New("The `repo` field is required")
	}
	project := "github:" + spec.Repo
	if sourceDir != "" {
		project = project + "/" + sourceDir
	}
	if spec.Branch != "" {
		project = project + "#" + spec.Branch
	}
	return project, nil
}

// Function to convert godo.LocalSourceSpec + source directory path to an appropriate project argument
// for 'nim project deploy'
func localProject(spec *godo.LocalSourceSpec, sourceDir string) (string, error) {
	if spec.Path != "" {
		if sourceDir != "" {
			return spec.Path + "/" + sourceDir, nil
		} else {
			return spec.Path, nil
		}
	} else if sourceDir != "" {
		return sourceDir, nil
	} else {
		return "", errors.New("If `local` is used, either the path or the sourceDir or both must be specified")
	}
}

// Get the "serverless URL" (the URL for invoking actions in the current namespace).  Somewhat confusingly, 'nim'
// provides this using '--web' flag.  This is historical, and not really wrong in that, in Nimbella, the static
// web assets are at the same URL.
func getServerlessURL() (string, error) {
	return runNim("auth", "current", "--web")
}

// Update the static sites portion of an app spec with the current serverless URL.  This is done by adding
// a build-time environment variable called SERVERLESS_URL to each static site found.
func addServerlessURLToStaticSites(sites []*godo.AppStaticSiteSpec) error {
	url, err := getServerlessURL()
	if err != nil {
		return err
	}
	for _, site := range sites {
		site.Envs, err = addURLToSite(url, site.Envs)
		if err != nil {
			return err
		}
	}
	return nil
}

// Insert a new SERVERLESS_URL environment variable in an 'envs' array (or modify an existing one)
func addURLToSite(url string, envs []*godo.AppVariableDefinition) ([]*godo.AppVariableDefinition, error) {
	// First see if the variable is already there; if so, that's an error.
	for _, env := range envs {
		if env.Key == "SERVERLESS_URL" {
			return envs, errors.New("Cannot add serverless URL to static site: the variable has a conflicting use")
		}
	}
	// Not there, so add one.
	newEnv := godo.AppVariableDefinition{
		Key:   "SERVERLESS_URL",
		Value: url,
		Scope: godo.AppVariableScope_BuildTime,
		Type:  godo.AppVariableType_General}
	return append(envs, &newEnv), nil
}

// For use with doctl, we support the following ways of finding `nim`.
// - the path provided in the NIM environment variable (takes precedence if present), used for
//   testing new `nim` builds.
// - A special captive installation in ~/.nimbella/cli.  This can be produced from one of the
//   'fat' tarballs generated by `@oclif/dev-cli`.  These are self-contained and are what the
//   installers use.  This is how I imagine a more "permanent" hybridization might look.
// - A `nim` found in the path (lowest precedence), provided for convenience to current Nimbella users.
// Note that (for now) the user must have separately established a Nimbella current namespace.  At some
// future integration point, there DO will provide the namespace and the API host.
func getNimPath() (string, error) {
	// Try environment first
	path := os.Getenv("NIM")
	if path != "" {
		// No further validation ... assume setter of variable got it right
		return path, nil
	}
	// Determine if a captive nim is present
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}
	path = filepath.Join(homeDir, ".nimbella", "cli", "bin", "nim")
	stat, err := os.Stat(path)
	if err == nil {
		// Maybe.  Sanity check executable bits.
		if stat.Mode()&0111 != 0 {
			// Does not really establish that it's executable by present user but if it fails it's
			// definitly not.
			return path, nil
		}
	}
	// Not in environment, and no captive nim, so we check whether `nim` is in PATH
	path, err = exec.LookPath("nim")
	if err == nil {
		return path, nil
	}
	return "", errors.New("There is no usable 'nim' installed on your system")
}

// Function to run any 'nim' command.
func runNim(args ...string) (string, error) {
	nim, err := getNimPath()
	if err != nil {
		return "", err
	}
	output, err := exec.Command(nim, args...).Output()
	combinedOutput := string(output)
	if err != nil {
		exitErr, ok := err.(*exec.ExitError)
		if ok {
			combinedOutput += string(exitErr.Stderr)
		}
		return combinedOutput, err
	}
	return combinedOutput, nil
}

// A 'nim' subcommand of doctl.  Perhaps not exactly what DO would end up exposing, 
// but shows what could be done.  More likely, selected parts of the doctl logic would 
// invoke 'nim' as needed.
func Nim(cmd *Command) *Command {
	return cmdBuilderWithInit(cmd, RunNimStub, "nim", "Run commands from Nimbella CLI",
		"The `doctl nim` command runs commands that were formerly available via the Nimbella CLI",
		Writer,
		false)
}

func RunNimStub(c *CmdConfig) error {
	output, err := runNim(c.Args...)
	fmt.Print(output)
	return err
}
